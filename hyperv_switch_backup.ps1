# powershell script to backup / restore Microsoft Hyper-V virtual switch configurations

# CHANGE LOG
# ----------
#  2025/03/31   njeffrey   Script created


# USAGE
# -----
# powershell.exe x:\path\to\hyperv-switch-backup-restore.ps1 -Mode backup
# powershell.exe x:\path\to\hyperv-switch-backup-restore.ps1 -Mode restore -FilePath c:\backups\hyperv\vswitch\MyServer.hyperv.switch.backup.json





param (
    [Parameter(Mandatory = $true)]
    [ValidateSet("backup", "restore")]
    [string]$Mode,
    [string]$FilePath
)

# Declare variables used for sending optional report via email
$send_email = "no"                                             # yes|no flag to send a copy of the JSON file via email
$hostname   = $env:computername                                # Figure out the local hostname
$to         = "recipient@example.com"                          #sysadmin that receives email report
$from       = "sender@example.com"                             #from address
$subject    = "Hyper-V virtual switch backup from $hostname"   #subject of email message
$smtpserver = "MySmtpServer.example.com"                       #SMTP smart host used for relaying the email
$port       = "25"                                             #SMTP TCP port
$destdir    = "c:\backup\hyperv\vswitch"                       #location of backups
$json_file  = "$hostname.hyperv.switch.backup.json"            #filename holding the backup


# confirm the script is running with administrator privileges
Write-Host "Confirming this script is running with administrative privileges"
If (-NOT ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Warning "You do not have Administrator rights to run this script!`nPlease re-run this script as an Administrator!"
    exit
}



# get current timestamp
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$defaultBackupPath = "C:\Backups\HyperV_SwitchBackup_$timestamp.json"
$logFile = "$destdir\$json_file.log"

function Write-Log {
    param ([string]$Message)
    $Message | Tee-Object -FilePath $logFile -Append
}


# Ensure backup folder exists
if (-not (Test-Path $destdir)) {
    New-Item -Path $destdir -ItemType Directory -Force | Out-Null
}



# run this section if the "-Mode backup" parameter was provided
if ($Mode -eq "backup") {
   $switches = Get-VMSwitch
   #
   # Force into array even if only one switch
   if ($switches -isnot [System.Collections.IEnumerable]) {
      $switches = @($switches)
   }
   #
   $exportData = @()
   #
   foreach ($switch in $switches) {
      switch ($switch.SwitchType.ToString()) {
         "1"        { $switchType = "External" }  #depending on the PowerShell version,
         "2"        { $switchType = "Internal" }  #the virtual switches may be defined as a numeric value 1,2,3
         "3"        { $switchType = "Private"  }  #or a text value External,Internal,Private
         "External" { $switchType = "External" }
         "Internal" { $switchType = "Internal" }
         "Private"  { $switchType = "Private"  }
         default    { $switchType = "Unknown"  }
      }
      #
      $exportData += [PSCustomObject]@{
         Name              = $switch.Name
         SwitchType        = $switchType
         Notes             = $switch.Notes
         AllowManagementOS = $switch.AllowManagementOS
         NetAdapterNames   = $switch.NetAdapterInterfaceDescription
      }
   }                      #end of foreach loop
   #
   $exportData | ConvertTo-Json -Depth 3 | Out-File -FilePath "$destdir\$json_file" -Encoding UTF8
   Write-Log "Backup completed: $destdir\$json_file"
   #
   # if required, send JSON file to sysadmin via email
   #
   if ($send_email -eq "yes") {
      # Put some explanatory text at the beginning of the backup report
      $body = "This report is generated by the $PSCommandPath script on $env:computername `n"
      #
      # append the contents of the JSON file to the $body variable
      $fileContent = Get-Content "$destdir\$json_file" -Raw
      $body += "`n$fileContent"
      #
      # send the email report
      Send-MailMessage -To $to -From $from -Subject $subject -Body $body -SmtpServer $smtpserver -Port $port
      #
      # HINT: if the SMTP server does not allow relaying for your server, you will get the following error:
      #Send-MailMessage : Mailbox unavailable. The server response was: 5.7.1 Relaying denied
   }
}                         #end of if blcok





# run this section if the "-Mode restore parameter was provided
if ($Mode -eq "restore") {
   #
   # confirm -FilePath parameter was provided
   #
   if (-not $FilePath) {
      Write-Error "Please provide -FilePath $destdir\$json_file for restore mode."
      exit 1
   }
   #
   # Confirm existence of the filename provided in "-FilePath x:\path\to\filename"
   #
   if (-not (Test-Path "$destdir\$json_file")) {
      Write-Error "File not found: $destdir\$json_file"
      exit 1
   }
   #
   # Open the JSON file and get all the details of the virtual switches
   #
   $switches = Get-Content "$destdir\$json_file" | ConvertFrom-Json
   #
   # If only one switch is restored, force into array
   if ($switches -isnot [System.Collections.IEnumerable]) {
      $switches = @($switches)
   }

   foreach ($sw in $switches) {
      $name = $sw.Name
      $type = $sw.SwitchType
      $notes = $sw.Notes
      $allowMgmt = $sw.AllowManagementOS
      $adapterName = $null                    #adapterName only exists on external switches, not internal or private
      if ($sw.SwitchType -eq "External" -and $sw.NetAdapterNames -and $sw.NetAdapterNames[0]) {
         $adapterName = $sw.NetAdapterNames[0]
      }

      if (Get-VMSwitch -Name $name -ErrorAction SilentlyContinue) {
         Write-Log "Switch '$name' already exists. Skipping."
         continue
      }

      Write-Log "Creating switch: $name ($type)"

      switch ($type) {
         "External" {
            if (-not $adapterName) {
               Write-Log "External switch '$name' missing adapter. Skipping."
               continue
            }
            New-VMSwitch -Name $name -NetAdapterName $adapterName -AllowManagementOS $allowMgmt
         }
         "Internal" {
            New-VMSwitch -Name $name -SwitchType Internal
         }
         "Private" {
            New-VMSwitch -Name $name -SwitchType Private
         }
         default {
            Write-Log "Unknown switch type '$type' for '$name'. Skipping."
            continue
         }
      }
      if ($notes) {
         Set-VMSwitch -Name $name -Notes $notes
      }
      Write-Log "Created virtual switch: $name"
   }
   Write-Log "Restore completed from: $FilePath"
}              #end of if block
